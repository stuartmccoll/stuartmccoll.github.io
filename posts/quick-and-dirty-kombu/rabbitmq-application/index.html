<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Stuart McColl "><meta name=description content="Kombu is an open-source messaging library available for Python which aims to make messaging as simple as possible. Kombu provides a high-level interface for the Advanced Message Queuing Protocol (AMQP), an open standard protocol for message orientation, queuing, routing, reliability, and security. The most popular implementation of AMQP is the RabbitMQ open-source messaging server.
In the example application we&amp;rsquo;re going to create here, we&amp;rsquo;re going to use Kombu and RabbitMQ in combination to do the following:"><meta name=keywords content="homepage,blog,development,programming"><meta name=robots content="noodp"><link rel=canonical href=https://stuartmccoll.github.io/posts/quick-and-dirty-kombu/rabbitmq-application/><title>Quick and Dirty Kombu/RabbitMQ Application :: Stuart McColl</title><link rel=stylesheet href=/main.min.15c204e66791e2f70ca06e7872b0ed743b4d2392b3c6dc31ba8dbd9f3d4618d2.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=/favicon.ico><meta name=theme-color content="#252627"><meta itemprop=name content="Quick and Dirty Kombu/RabbitMQ Application"><meta itemprop=description content="Quick and Dirty Kombu/RabbitMQ Application"><meta itemprop=datePublished content="2017-05-14T10:10:32+00:00"><meta itemprop=dateModified content="2017-05-14T10:10:32+00:00"><meta itemprop=wordCount content="989"><meta itemprop=image content="https://stuartmccoll.github.io"><meta itemprop=keywords content><meta property="article:published_time" content="2017-05-14 10:10:32 +0000 UTC"><script type=text/javascript>!function(b,d,a){var e=b.location,o="script",n="instrumentationKey",g="ingestionendpoint",k="disableExceptionTracking",i="ai.device.",j="toLowerCase",h="crossOrigin",l="POST",m="appInsightsSDK",f=a.name||"appInsights",c;(a.name||b[m])&&(b[m]=f),c=b[f]||function(f){var z=!1,q=!1,c={initialize:!0,queue:[],sv:"5",version:2,config:f},r,s,m,x,y,B,p,A;function w(b,f){var a={},d="Browser";return a[i+"id"]=d[j](),a[i+"type"]=d,a["ai.operation.name"]=e&&e.pathname||"_unknown_",a["ai.internal.sdkVersion"]="javascript:snippet_"+(c.sv||c.version),{time:function(){var a=new Date;function b(b){var a=""+b;return 1===a.length&&(a="0"+a),a}return a.getUTCFullYear()+"-"+b(1+a.getUTCMonth())+"-"+b(a.getUTCDate())+"T"+b(a.getUTCHours())+":"+b(a.getUTCMinutes())+":"+b(a.getUTCSeconds())+"."+((a.getUTCMilliseconds()/1e3).toFixed(3)+"").slice(2,5)+"Z"}(),iKey:b,name:"Microsoft.ApplicationInsights."+b.replace(/-/g,"")+"."+f,sampleRate:100,tags:a,data:{baseData:{ver:2}}}}if(r=f.url||a.src,r){function u(x){var h,i,t,u,v,s,o,p,k,d,m;z=!0,c.queue=[],q||(q=!0,h=r,o=function(){var a={},d=f.connectionString,e,b,c,h,i;if(d)for(e=d.split(";"),b=0;b<e.length;b++)c=e[b].split("="),2===c.length&&(a[c[0][j]()]=c[1]);return a[g]||(h=a.endpointsuffix,i=h?a.location:null,a[g]="https://"+(i?i+".":"")+"dc."+(h||"services.visualstudio.com")),a}(),p=o[n]||f[n]||"",k=o[g],d=k?k+"/v2/track":f.endpointUrl,(m=[]).push((i="SDK LOAD Failure: Failed to load Application Insights SDK script (See stack for details)",t=h,u=d,(s=(v=w(p,"Exception")).data).baseType="ExceptionData",s.baseData.exceptions=[{typeName:"SDKLoadFailed",message:i.replace(/\./g,"-"),hasFullStack:!1,stack:i+"\nSnippet failed to load ["+t+"] -- Telemetry is disabled\nHelp Link: https://go.microsoft.com/fwlink/?linkid=2128109\nHost: "+(e&&e.pathname||"_unknown_")+"\nEndpoint: "+u,parsedStack:[]}],v)),m.push(function(g,f,d,e){var b=w(p,"Message"),c=b.data,a;return c.baseType="MessageData",a=c.baseData,a.message='AI (Internal): 99 message:"'+("SDK LOAD Failure: Failed to load Application Insights SDK script (See stack for details) ("+d+")").replace(/\"/g,"")+'"',a.properties={endpoint:e},b}(0,0,h,d)),function(e,f){var d,c;JSON&&(d=b.fetch,d&&!a.useXhr?d(f,{method:l,body:JSON.stringify(e),mode:"cors"}):XMLHttpRequest&&(c=new XMLHttpRequest,c.open(l,f),c.setRequestHeader("Content-type","application/json"),c.send(JSON.stringify(e))))}(m,d))}function t(b,a){q||setTimeout(function(){!a&&c.core||u()},500)}s=function(){var b=d.createElement(o),c;return b.src=r,c=a[h],!c&&""!==c||"undefined"==b[h]||(b[h]=c),b.onload=t,b.onerror=u,b.onreadystatechange=function(c,a){"loaded"!==b.readyState&&"complete"!==b.readyState||t(0,a)},b}(),a.ld<0?d.getElementsByTagName("head")[0].appendChild(s):setTimeout(function(){d.getElementsByTagName(o)[0].parentNode.appendChild(s)},a.ld||0)}try{c.cookie=d.cookie}catch(a){}function v(a){for(;a.length;)!function(a){c[a]=function(){var b=arguments;z||c.queue.push(function(){c[a].apply(c,b)})}}(a.pop())}return m="track",x="TrackPage",y="TrackEvent",v([m+"Event",m+"PageView",m+"Exception",m+"Trace",m+"DependencyData",m+"Metric",m+"PageViewPerformance","start"+x,"stop"+x,"start"+y,"stop"+y,"addTelemetryInitializer","setAuthenticatedUserContext","clearAuthenticatedUserContext","flush"]),c.SeverityLevel={Verbose:0,Information:1,Warning:2,Error:3,Critical:4},B=(f.extensionConfig||{}).ApplicationInsightsAnalytics||{},!0!==f[k]&&!0!==B[k]&&(p="onerror",v(["_"+p]),A=b[p],b[p]=function(a,b,d,e,f){var g=A&&A(a,b,d,e,f);return!0!==g&&c["_"+p]({message:a,url:b,lineNumber:d,columnNumber:e,error:f}),g},f.autoExceptionInstrumented=!0),c}(a.cfg);function p(){a.onInit&&a.onInit(c)}(b[f]=c).queue&&0===c.queue.length?(c.queue.push(p),c.trackPageView({})):p()}(window,document,{src:"https://js.monitor.azure.com/scripts/b/ai.2.min.js",crossOrigin:"anonymous",cfg:{connectionString:"InstrumentationKey=74cc5c48-d066-4928-932e-459f438b579d;IngestionEndpoint=https://uksouth-1.in.applicationinsights.azure.com/;LiveEndpoint=https://uksouth.livediagnostics.monitor.azure.com/"}})</script></head><body><div class=container><header><section><h1 class=site-heading>Stuart McColl</h1><nav><ul><li><a href=/>Blog</a></li><li><a href=/about>About</a></li></ul></nav></section></header><hr><div class=content><main class=post><article><header><h1 class=post-title>Quick and Dirty Kombu/RabbitMQ Application</h1><p class=post-date>May 14, 14140</p></header><hr class=post-rule><div class=post-content><p><a href=https://github.com/celery/kombu>Kombu</a> is an open-source messaging library available for Python which aims to make messaging as simple as possible. Kombu provides a high-level interface for the <a href=http://amqp.org/>Advanced Message Queuing Protocol</a> (AMQP), an open standard protocol for message orientation, queuing, routing, reliability, and security. The most popular implementation of AMQP is the <a href=http://www.rabbitmq.com/>RabbitMQ</a> open-source messaging server.</p><p>In the example application we&rsquo;re going to create here, we&rsquo;re going to use Kombu and RabbitMQ in combination to do the following:</p><ul><li>Send a message from a Kombu application (in this case a simple Python script).</li><li>Receive the message at an exchange (our RabbitMQ server), which will then place the message on a queue.</li><li>Read from the queue within another Kombu application (in this case, another simple Python script).</li></ul><p>The application we&rsquo;re going to create will only feature one queue, one script which will fire a message at the exchange (our producer), and another script that will read from the queue as soon as it finds something on it (our consumer). It&rsquo;s a basic example, but we could build upon and utilise this for any number of uses.</p><h2 id=tutorial>Tutorial</h2><p>Let&rsquo;s begin with our script that&rsquo;ll consume messages - <code>consumer.py</code>.</p><p>In order to send and receive messages, we&rsquo;ll need to fulfil a few prerequisites. Firstly, we need to create a connection to our RabbitMQ server.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>conn</span> <span class=o>=</span> <span class=n>Connection</span><span class=p>(</span><span class=s2>&#34;amqp://localhost:5672/&#34;</span><span class=p>)</span>
</code></pre></div><p>We&rsquo;ll use this connection in a moment when we instantiate the Consumer class. Next, we&rsquo;ll create our exchange.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>test_exchange</span> <span class=o>=</span> <span class=n>Exchange</span><span class=p>(</span><span class=s2>&#34;test_exchange&#34;</span><span class=p>,</span> <span class=nb>type</span><span class=o>=</span><span class=s2>&#34;direct&#34;</span><span class=p>)</span>
</code></pre></div><p>The first parameter passed gives the name of our exchange and the second parameter dictates what type of exchange we&rsquo;re creating. Here, we can pass either direct (matches if the routing_key attribute and the routing key property of the message are identical), fanout (always matches), and topic (matches the routing key property of the message by a pattern matching scheme). For this small example we&rsquo;re going to create a simple direct exchange.</p><p>With a connection and an exchange created, we&rsquo;re now going to create our queue. This is what we&rsquo;ll drop our messages onto before consuming them.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>queue</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s2>&#34;queue&#34;</span><span class=p>,</span> <span class=n>exchange</span><span class=o>=</span><span class=n>test_exchange</span><span class=p>,</span> <span class=n>routing_key</span><span class=o>=</span><span class=s2>&#34;test&#34;</span><span class=p>)</span>
</code></pre></div><p>To configure our queue, we&rsquo;re simply giving it a name, passing an exchange to it, and a routing key. The routing key will be utilised based on the type of the exchange, as we&rsquo;ve set above.</p><p>Lastly, we need to set up our Consumer. A Consumer needs a connection (or channel) and a list of queues to consume from. We&rsquo;re also going to pass it a callback, which is a function which it&rsquo;ll call when it finds an event on our queue.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>with</span> <span class=n>Consumer</span><span class=p>(</span><span class=n>conn</span><span class=p>,</span> <span class=n>queues</span><span class=o>=</span><span class=n>queue</span><span class=p>,</span> <span class=n>callbacks</span><span class=o>=</span><span class=p>[</span><span class=n>process_message</span><span class=p>],</span> <span class=n>accept</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;text/plain&#34;</span><span class=p>]):</span>
    <span class=n>conn</span><span class=o>.</span><span class=n>drain_events</span><span class=p>()</span>
</code></pre></div><p>Our Consumer takes our connection variable, our queue, and a callback to a process_message function which we&rsquo;ll create in a moment. We&rsquo;re not passing any kind of timeout only because for this example we want it to consume messages indefinitely to give an idea of how Kombu and RabbitMQ work. I&rsquo;ll expand upon this further in future posts where I&rsquo;ll be looking at putting Kombu to a more functional use.</p><p>Here&rsquo;s our <code>consumer.py</code> file in full:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>kombu</span> <span class=kn>import</span> <span class=n>Connection</span><span class=p>,</span> <span class=n>Exchange</span><span class=p>,</span> <span class=n>Consumer</span><span class=p>,</span> <span class=n>Queue</span>
<span class=kn>from</span> <span class=nn>process_message</span> <span class=kn>import</span> <span class=n>process_message</span>

<span class=c1># Create the connection</span>
<span class=n>conn</span> <span class=o>=</span> <span class=n>Connection</span><span class=p>(</span><span class=s2>&#34;amqp://localhost:5672/&#34;</span><span class=p>)</span>

<span class=c1># Create the exchange</span>
<span class=n>test_exchange</span> <span class=o>=</span> <span class=n>Exchange</span><span class=p>(</span><span class=s2>&#34;test_exchange&#34;</span><span class=p>,</span> <span class=nb>type</span><span class=o>=</span><span class=s2>&#34;direct&#34;</span><span class=p>)</span>

<span class=c1># Create the queue</span>
<span class=n>queue</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s2>&#34;queue&#34;</span><span class=p>,</span> <span class=n>exchange</span><span class=o>=</span><span class=n>test_exchange</span><span class=p>,</span> <span class=n>routing_key</span><span class=o>=</span><span class=s2>&#34;test&#34;</span><span class=p>)</span>

<span class=c1># Create the consumer</span>
<span class=k>with</span> <span class=n>Consumer</span><span class=p>(</span><span class=n>conn</span><span class=p>,</span> <span class=n>queues</span><span class=o>=</span><span class=n>queue</span><span class=p>,</span> <span class=n>callbacks</span><span class=o>=</span><span class=p>[</span><span class=n>process_message</span><span class=p>],</span>
              <span class=n>accept</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;text/plain&#34;</span><span class=p>]):</span>
</code></pre></div><p>Now, to create our <code>process_message</code> function. This is going to live in it&rsquo;s own <code>process_message.py</code> file.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>process_message</span><span class=p>(</span><span class=n>body</span><span class=p>,</span> <span class=n>message</span><span class=p>):</span>
    <span class=k>print</span> <span class=s2>&#34;The following message has been received: </span><span class=si>%s</span><span class=s2>&#34;</span> <span class=o>%</span> <span class=n>body</span>

    <span class=c1># Acknowledge the message</span>
    <span class=n>message</span><span class=o>.</span><span class=n>ack</span><span class=p>()</span>
</code></pre></div><p>This function receives the body and message of our event, prints a statement to the console detailing what has been received, then acknowledges the message. By acknowledging the message we remove it from the queue.</p><p>At this stage, we have our queue ready to put messages on, we&rsquo;ve got a consumer that&rsquo;s ready to grab messages off the queue, and we&rsquo;ve also got a function that&rsquo;s going to process the message once we&rsquo;ve taken it from the queue. The only thing left to do is to set up our producer, which is what will drop our messages onto the queue.</p><p>A lot of our <code>producer.py</code> file is going to look similar to our <code>consumer.py</code> file.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>conn</span> <span class=o>=</span> <span class=n>Connection</span><span class=p>(</span><span class=s2>&#34;amqp://localhost:5672/&#34;</span><span class=p>)</span>
</code></pre></div><p>We need to set up our connection as before.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>channel</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>channel</span><span class=p>()</span>
</code></pre></div><p>Then we create and return a new channel.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>test_exchange</span> <span class=o>=</span> <span class=n>Exchange</span><span class=p>(</span><span class=s2>&#34;test_exchange&#34;</span><span class=p>,</span> <span class=nb>type</span><span class=o>=</span><span class=s2>&#34;direct&#34;</span><span class=p>)</span>
</code></pre></div><p>We create our exchange in the same way that we did within our <code>consumer.py</code> file.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>producer</span> <span class=o>=</span> <span class=n>Producer</span><span class=p>(</span><span class=n>exchange</span><span class=o>=</span><span class=n>test_exchange</span><span class=p>,</span> <span class=n>channel</span><span class=o>=</span><span class=n>channel</span><span class=p>,</span> <span class=n>routing_key</span><span class=o>=</span><span class=s2>&#34;test&#34;</span><span class=p>)</span>
</code></pre></div><p>Our instantiation of the Producer class looks similar to the way we instantiated our Consumer class. We pass in our exchange and our channel, and then we also pass in the same routing_key that we gave to our consumer. As we&rsquo;re using a direct exchange, we need to make sure that our messages are going to the same place, which is why we ensure that we pass in the same routing_key to both the producer and the consumer.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>producer</span><span class=o>.</span><span class=n>publish</span><span class=p>(</span><span class=s2>&#34;Hello World!&#34;</span><span class=p>)</span>
</code></pre></div><p>Lastly, we call the publish method and pass through a string as our message. Whenever we run the <code>producer.py</code> script this will send our message to the exchange.</p><p>Here&rsquo;s our <code>producer.py</code> in full:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>kombu</span> <span class=kn>import</span> <span class=n>Connection</span><span class=p>,</span> <span class=n>Exchange</span><span class=p>,</span> <span class=n>Producer</span>

<span class=c1># Create the connection</span>
<span class=n>conn</span> <span class=o>=</span> <span class=n>Connection</span><span class=p>(</span><span class=s2>&#34;amqp://localhost:5672/&#34;</span><span class=p>)</span>

<span class=c1># Create a new channel</span>
<span class=n>channel</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>channel</span><span class=p>()</span>

<span class=c1># Create the exchange</span>
<span class=n>test_exchange</span> <span class=o>=</span> <span class=n>Exchange</span><span class=p>(</span><span class=s2>&#34;test_exchange&#34;</span><span class=p>,</span> <span class=nb>type</span><span class=o>=</span><span class=s2>&#34;direct&#34;</span><span class=p>)</span>

<span class=c1># Create the producer</span>
<span class=n>producer</span> <span class=o>=</span> <span class=n>Producer</span><span class=p>(</span><span class=n>exchange</span><span class=o>=</span><span class=n>test_exchange</span><span class=p>,</span> <span class=n>channel</span><span class=o>=</span><span class=n>channel</span><span class=p>,</span>
                    <span class=n>routing_key</span><span class=o>=</span><span class=s2>&#34;test&#34;</span><span class=p>)</span>

<span class=c1># Publish a message</span>
<span class=n>producer</span><span class=o>.</span><span class=n>publish</span><span class=p>(</span><span class=s2>&#34;Hello World!&#34;</span><span class=p>)</span>
</code></pre></div><p>If we run our <code>consumer.py</code> script now, it&rsquo;ll run indefinitely and wait until it finds something on the queue we&rsquo;ve created. Now, if we run <code>producer.py</code> it&rsquo;ll fire a message at the exchange which will route it onto the queue. The already-running <code>consumer.py</code> will find it on the queue and process it, which removes it from the queue.</p><p>A simple example that doesn&rsquo;t do anything of use, but I hope it&rsquo;s given you an insight into the way Kombu and RabbitMQ work together.</p></div></article></main></div><hr><footer><section><h3>More</h3><ul><li><a href=https://hachyderm.io/@stuartmccoll rel=me>Contact me on Mastodon</a></li><li>Spotted a bug in the site?
<a href=https://github.com/stuartmccoll/hugo-theme-refresh/issues/new>Raise an issue on GitHub</a></li><li>Get notifications of new posts by
<a href=https://stuartmccoll.github.io/index.xml>subscribing to my RSS feed</a></li><li>This static site was generated using
<a href=https://github.com/gohugoio/hugo/releases/tag/v0.83.1>Hugo version 0.83.1</a></li></ul></section><hr><section><h3>Attribution</h3><p xmlns:dct=http://purl.org/dc/terms/ xmlns:cc=http://creativecommons.org/ns# class=license-text>This blog post <span rel=dct:title>(Quick and Dirty Kombu/RabbitMQ Application)</span> is licensed under
<a href=https://creativecommons.org/licenses/by/4.0>CC BY 4.0</a>. Any code contained within
this article may be subject to other licenses.</p></section></footer></div></body></html>