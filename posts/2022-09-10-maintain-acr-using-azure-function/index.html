<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Stuart McColl "><meta name=description content="This year I created a small C# CLI application that scrapes this website and stores the results in Azure Blob Storage. It&amp;rsquo;s essentially a not-very-good version of the the Internet Archive&amp;rsquo;s Wayback Machine, but specific only to this website.
The process happens in two parts. If I merge any pull requests on the website-archiver into main, then a GitHub Actions workflow pushes the latest Docker image to an Azure Container Registry."><meta name=keywords content="homepage,blog,development,programming"><meta name=robots content="noodp"><link rel=canonical href=https://stuartmccoll.github.io/posts/2022-09-10-maintain-acr-using-azure-function/><title>Maintain an Azure Container Registry using a PowerShell Azure Function :: Stuart McColl</title><link rel=stylesheet href=/main.min.204e05be3bf8f06e400f4478e75c46ae9e3015935b7dd6625b19338e6625499b.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=/favicon.ico><meta name=theme-color content="#252627"><meta itemprop=name content="Maintain an Azure Container Registry using a PowerShell Azure Function"><meta itemprop=description content="This year I created a small C# CLI application that scrapes this website and stores the results in Azure Blob Storage. It&rsquo;s essentially a not-very-good version of the the Internet Archive&rsquo;s Wayback Machine, but specific only to this website.
The process happens in two parts. If I merge any pull requests on the website-archiver into main, then a GitHub Actions workflow pushes the latest Docker image to an Azure Container Registry."><meta itemprop=datePublished content="2022-09-10T23:00:00+01:00"><meta itemprop=dateModified content="2022-06-11T23:00:00+01:00"><meta itemprop=wordCount content="721"><meta itemprop=image content="https://stuartmccoll.github.io"><meta itemprop=keywords content="Automation,Microsoft Azure,Azure Functions,PowerShell,"><meta property="article:section" content="Automation"><meta property="article:section" content="Microsoft Azure"><meta property="article:section" content="Azure Functions"><meta property="article:section" content="PowerShell"><meta property="article:published_time" content="2022-09-10 23:00:00 +0100 +0100"></head><body><div class=container><header><section><h1 class=site-heading>Stuart McColl</h1><nav><ul><li><a href=/>Blog</a></li><li><a href=/about>About</a></li></ul></nav></section></header><hr><div class=content><main class=post><article><header><h1 class=post-title>Maintain an Azure Container Registry using a PowerShell Azure Function</h1><p class=post-date>September 10, 2022</p></header><hr class=post-rule><div class=post-content><p>This year I created a small C# CLI application that scrapes this website and
stores the results in Azure Blob Storage. It&rsquo;s essentially a not-very-good
version of the the <a href=https://archive.org/>Internet Archive</a>&rsquo;s
<a href=https://web.archive.org/>Wayback Machine</a>, but specific only to this website.</p><p>The process happens in two parts. If I merge any pull requests on the
<a href=https://github.com/stuartmccoll/website-archiver>website-archiver</a> into
<code>main</code>, then a GitHub Actions workflow pushes the latest Docker image to an
Azure Container Registry. If I merge any pull requests on the repository that
holds the codebase for this website, then another GitHub Actions workflow
triggers the deployment of an Azure Container Instance using the <code>latest</code>
tagged image in the aforementioned Azure Container Registry. The container
runs, the website is scraped and stored in Azure Blob Storage, and then
the container exits.</p><p>So far, this is working well. When I update this website, within a minute or
two I can see the most recently scraped version land in Azure Blob Storage.
Whilst I plan to hang on to all of these &lsquo;scrapes&rsquo;, what I don&rsquo;t need to hang
onto in the long term is outdated container images for the website archiver
itself. I could manually drop into the Azure Container Registry every once
in a while and remove any that aren&rsquo;t needed - it&rsquo;s not as if I&rsquo;m frequently
uploading updated images - but this seems like something that should be easy
enough to automate.</p><h2 id=removing-images-from-azure-container-registry-using-powershell>Removing images from Azure Container Registry using PowerShell</h2><p>Rather than head straight for an Azure Function, we&rsquo;ll test the theory in our
local <a href=https://docs.microsoft.com/en-us/windows/terminal/>Windows Terminal</a>
first. I want to:</p><ul><li>List the available images in an Azure Container Registry repository, ordered
by when they were last updated.</li><li>If there are more than five images available, then I want to remove all
<em>except</em> the most recently updated five images.</li></ul><p>We&rsquo;ll use two cmdlets, one for each action above;
<a href=https://docs.microsoft.com/en-us/powershell/module/az.containerregistry/get-azcontainerregistrytag><code>Get-AzContainerRegistryTag</code></a> and
<a href=https://docs.microsoft.com/en-us/powershell/module/az.containerregistry/remove-azcontainerregistrytag><code>Remove-AzContainerRegistryTag</code></a>.</p><p>First, we retrieve <em>all</em> available tagged images in an Azure Container Registry
repository.</p><div class=highlight><pre class=chroma><code class=language-powershell data-lang=powershell><span class=nv>$Tags</span> <span class=p>=</span> <span class=p>(</span><span class=nb>Get-AzContainerRegistryTag</span> <span class=n>-RepositoryName</span> <span class=s2>&#34;RepoName&#34;</span> <span class=p>`</span>
<span class=n>-RegistryName</span> <span class=s2>&#34;RegName&#34;</span><span class=p>).</span><span class=n>Tags</span> <span class=p>|</span> <span class=nb>Sort-Object</span> <span class=n>LastUpdateTime</span> <span class=p>|</span> <span class=nb>Select-Object</span> <span class=n>Name</span>
</code></pre></div><p>Now, if <code>$Tags</code> contains more than five tagged images, we want to remove all
but the five most recent.</p><div class=highlight><pre class=chroma><code class=language-powershell data-lang=powershell><span class=k>if</span> <span class=p>(</span><span class=nv>$Tags</span><span class=p>.</span><span class=n>Length</span> <span class=o>-gt</span> <span class=n>5</span><span class=p>)</span>
<span class=p>{</span>

  <span class=k>Foreach</span> <span class=p>(</span><span class=nv>$Tag</span> <span class=k>in</span> <span class=nv>$Tags</span><span class=p>[</span><span class=n>0</span><span class=p>..(</span><span class=nv>$Tags</span><span class=p>.</span><span class=n>Length</span> <span class=p>-</span> <span class=n>5</span><span class=p>)])</span>
  <span class=p>{</span>
    <span class=nb>Remove-AzContainerRegistryTag</span> <span class=n>-RepositoryName</span> <span class=s2>&#34;RepoName&#34;</span> <span class=p>`</span>
    <span class=n>-RegistryName</span> <span class=s2>&#34;RegName&#34;</span> <span class=n>-Name</span> <span class=nv>$Tag</span><span class=p>.</span><span class=n>Name</span>
  <span class=p>}</span>

<span class=p>}</span>
</code></pre></div><p>That&rsquo;s the extent of the PowerShell we&rsquo;ll write here, other than a bit of
logging output for our Azure Function.</p><h2 id=running-an-azure-function-on-a-timer>Running an Azure Function on a timer</h2><p>After creating an Azure Function App (using the PowerShell Core runtime stack),
we&rsquo;ve got an extra step before we add our code or configure our timer. We&rsquo;ll
need to make the <code>Az.ContainerRegistry</code> PowerShell module available to our
Function. This can be done by heading to &lsquo;App files&rsquo;, and adding the following
line to <code>requirements.psd1</code>:</p><div class=highlight><pre class=chroma><code class=language-powershell data-lang=powershell><span class=s1>&#39;Az.ContainerRegistry&#39;</span> <span class=p>=</span> <span class=s1>&#39;3.0.0&#39;</span>
</code></pre></div><p>Configuring the timer is done when creating the Azure Function itself; select
&lsquo;Timer trigger&rsquo; from the available templates. Give it a name, and enter a
cron expression to specify the schedule that the Azure Function will run on.
I&rsquo;ve gone with <code>0 30 23 * * Sat</code>, which equates to 23:30 every Saturday. The
cron format in Azure is <code>{second} {minute} {hour} {day} {month} {day of week}</code>.</p><p>Azure will pre-populate our Azure Function with some boilerplate, which we&rsquo;ll
leave for now, inserting our full code in the middle:</p><div class=highlight><pre class=chroma><code class=language-powershell data-lang=powershell><span class=c># Input bindings are passed in via param block.</span>
<span class=k>param</span><span class=p>(</span><span class=nv>$Timer</span><span class=p>)</span>

<span class=c># Get the current universal time in the default string format.</span>
<span class=nv>$currentUTCtime</span> <span class=p>=</span> <span class=p>(</span><span class=nb>Get-Date</span><span class=p>).</span><span class=n>ToUniversalTime</span><span class=p>()</span>

<span class=c># The &#39;IsPastDue&#39; property is &#39;true&#39; when the current function invocation is</span>
<span class=c># later than scheduled.</span>
<span class=k>if</span> <span class=p>(</span><span class=nv>$Timer</span><span class=p>.</span><span class=n>IsPastDue</span><span class=p>)</span> <span class=p>{</span>
    <span class=nb>Write-Host</span> <span class=s2>&#34;PowerShell timer is running late!&#34;</span>
<span class=p>}</span>

<span class=nb>Write-Host</span> <span class=s2>&#34;Retrieving Azure Container Registry Repository Tags in &#34;</span><span class=p>`</span>
<span class=s2>&#34;descending order of LastUpdatedTime&#34;</span>

<span class=nv>$Tags</span> <span class=p>=</span> <span class=p>(</span><span class=nb>Get-AzContainerRegistryTag</span> <span class=n>-RepositoryName</span> <span class=s2>&#34;RepoName&#34;</span> <span class=p>`</span>
<span class=n>-RegistryName</span> <span class=s2>&#34;RegName&#34;</span><span class=p>).</span><span class=n>Tags</span> <span class=p>|</span> <span class=nb>Sort-Object</span> <span class=n>LastUpdateTime</span> <span class=p>|</span> <span class=p>`</span>
<span class=nb>Select-Object</span> <span class=n>Name</span>

<span class=nb>Write-Host</span> <span class=s2>&#34;Finished retrieving </span><span class=p>$(</span><span class=nv>$Tags</span><span class=p>.</span><span class=n>Length</span><span class=p>)</span><span class=s2> Azure Container Registry &#34;</span> <span class=p>`</span>
<span class=s2>&#34;Repository Tags in descending order of LastUpdatedTime&#34;</span>

<span class=k>if</span> <span class=p>(</span><span class=nv>$Tags</span><span class=p>.</span><span class=n>Length</span> <span class=o>-gt</span> <span class=n>5</span><span class=p>)</span>
<span class=p>{</span>

    <span class=nb>Write-Host</span> <span class=s2>&#34;More than 5 tags found for Azure Container Registry Repository&#34;</span>

    <span class=k>Foreach</span> <span class=p>(</span><span class=nv>$Tag</span> <span class=k>in</span> <span class=nv>$Tags</span><span class=p>[</span><span class=n>0</span><span class=p>..(</span><span class=nv>$Tags</span><span class=p>.</span><span class=n>Length</span> <span class=p>-</span> <span class=n>5</span><span class=p>)])</span>
    <span class=p>{</span>
        <span class=nb>Write-Host</span> <span class=s2>&#34;Removing Tag </span><span class=p>$(</span><span class=nv>$Tag</span><span class=p>.</span><span class=n>Name</span><span class=p>)</span><span class=s2>&#34;</span>
        <span class=nb>Remove-AzContainerRegistryTag</span> <span class=n>-RepositoryName</span> <span class=s2>&#34;RepoName&#34;</span> <span class=p>`</span>
        <span class=n>-RegistryName</span> <span class=s2>&#34;RegName&#34;</span> <span class=n>-Name</span> <span class=nv>$Tag</span><span class=p>.</span><span class=n>Name</span>
    <span class=p>}</span>

<span class=p>}</span>

<span class=c># Write an information log with the current time.</span>
<span class=nb>Write-Host</span> <span class=s2>&#34;PowerShell timer trigger function ran! TIME: $currentUTCtime&#34;</span>

</code></pre></div><p>This is now happily running in my Azure account, limiting the amount of storage
that I&rsquo;m using in this particular Azure Container Registry.</p></div></article></main></div><hr><footer><section><h3>More</h3><ul><li><a href=https://hachyderm.io/@stuartmccoll rel=me>Contact me on Mastodon</a></li><li>Spotted a bug in the site?
<a href=https://github.com/stuartmccoll/hugo-theme-refresh/issues/new>Raise an issue on GitHub</a></li><li>Get notifications of new posts by
<a href=https://stuartmccoll.github.io/index.xml>subscribing to my RSS feed</a></li><li>This static site was generated using
<a href=https://github.com/gohugoio/hugo/releases/tag/v0.83.1>Hugo version 0.83.1</a></li></ul></section><hr><section><h3>Attribution</h3><p xmlns:dct=http://purl.org/dc/terms/ xmlns:cc=http://creativecommons.org/ns# class=license-text>This blog post <span rel=dct:title>(Maintain an Azure Container Registry using a PowerShell Azure Function)</span> is licensed under
<a href=https://creativecommons.org/licenses/by/4.0>CC BY 4.0</a>. Any code contained within
this article may be subject to other licenses.</p></section></footer></div></body></html>