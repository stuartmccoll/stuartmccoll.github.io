<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Stuart McColl "><meta name=description content="The aggregator design pattern is a simple way of providing a single, unified service capable of surfacing data from multiple microservices, and a commonly used pattern when implementing a microservice-based architecture.
Let&amp;rsquo;s imagine that we&amp;rsquo;ve been tasked with developing an internal API for our organisation - a general practice clinic. The API needs to consume data from three existing microservices, each of which is used by other services within the practice&amp;rsquo;s architecture - some services call these individually, some call all three."><meta name=keywords content="homepage,blog,development,programming"><meta name=robots content="noodp"><link rel=canonical href=https://stuartmccoll.github.io/posts/microservice-design-patterns-aggregator/><title>Microservice Design Patterns: Aggregator :: Stuart McColl</title><link rel=stylesheet href=/main.min.15c204e66791e2f70ca06e7872b0ed743b4d2392b3c6dc31ba8dbd9f3d4618d2.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=/favicon.ico><meta name=theme-color content="#252627"><meta itemprop=name content="Microservice Design Patterns: Aggregator"><meta itemprop=description content="Microservice Design Patterns: Aggregator"><meta itemprop=datePublished content="2019-06-17T10:00:00+00:00"><meta itemprop=dateModified content="2019-06-17T10:00:00+00:00"><meta itemprop=wordCount content="319"><meta itemprop=image content="https://stuartmccoll.github.io"><meta itemprop=keywords content="microservices,design patterns,software,"><meta property="article:published_time" content="2019-06-17 10:00:00 +0000 UTC"></head><body><div class=container><header><section><h1 class=site-heading>Stuart McColl</h1><nav><ul><li><a href=/>Blog</a></li><li><a href=/about>About</a></li></ul></nav></section></header><hr><div class=content><main class=post><article><header><h1 class=post-title>Microservice Design Patterns: Aggregator</h1><p class=post-date>June 17, 2019</p></header><hr class=post-rule><div class=post-content><p>The aggregator design pattern is a simple way of providing a single, unified service capable of surfacing data from multiple microservices, and a commonly used pattern when implementing a microservice-based architecture.</p><p>Let&rsquo;s imagine that we&rsquo;ve been tasked with developing an internal API for our organisation - a general practice clinic. The API needs to consume data from three existing microservices, each of which is used by other services within the practice&rsquo;s architecture - some services call these individually, some call all three.</p><p>The requirements for the API are that it should return simple details for a patient, a list of their allergies and a list of medication that they are currently taking.</p><p>Our three existing microservices are as follows:</p><ul><li><em>Existing Service #1</em> returns details about a patient - their name, age, etc.</li><li><em>Existing Service #2</em> returns a list of allergies that the patient has.</li><li><em>Existing Service #3</em> returns a list of medication that the patient is currently taking.</li></ul><p>Usually, we&rsquo;d expect an aggregator to make synchronous calls to relevant microservices, performing any necessary business logic on each result as it receives it and then packaging this up as an API endpoint for a consumer to use. This meets our requirements whilst opening up potential for re-use and decoupling.</p><p>Rather than increasing the number of services which call these microservices directly, we can make use of the aggregator pattern here.</p><p><img src=/img/aggregator-architecture.png alt="Simple component diagram demonstrating an example of the aggregator design pattern"></p><p>Our new internal API will call our new aggregator microservice, which will call the three existing microservices before then pushing the necessary results back up to the internal API.</p><p>We can re-use our aggregator within other services which call <em>all three</em> existing services, decoupling these from direct interaction with the microservices, which will make it easier to replace one later down the line; if we want to suddenly commission a new allergies microservice, we only have to update the aggregator (and those services which don&rsquo;t call <em>all three</em> existing services).</p></div></article></main></div><hr><footer><section><h3>More</h3><ul><li><a href=https://hachyderm.io/@stuartmccoll rel=me>Contact me on Mastodon</a></li><li>Spotted a bug in the site?
<a href=https://github.com/stuartmccoll/hugo-theme-refresh/issues/new>Raise an issue on GitHub</a></li><li>Get notifications of new posts by
<a href=https://stuartmccoll.github.io/index.xml>subscribing to my RSS feed</a></li><li>This static site was generated using
<a href=https://github.com/gohugoio/hugo/releases/tag/v0.83.1>Hugo version 0.83.1</a></li></ul></section><hr><section><h3>Attribution</h3><p xmlns:dct=http://purl.org/dc/terms/ xmlns:cc=http://creativecommons.org/ns# class=license-text>This blog post <span rel=dct:title>(Microservice Design Patterns: Aggregator)</span> is licensed under
<a href=https://creativecommons.org/licenses/by/4.0>CC BY 4.0</a>. Any code contained within
this article may be subject to other licenses.</p></section></footer></div></body></html>