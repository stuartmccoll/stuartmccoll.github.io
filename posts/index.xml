<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Stuart McColl</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Stuart McColl</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Sun, 03 Feb 2019 10:10:32 +0000</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>HackTheBox Lernaen Write-Up</title>
            <link>/posts/hackthebox-lernaen-write-up/</link>
            <pubDate>Sun, 03 Feb 2019 10:10:32 +0000</pubDate>
            
            <guid>/posts/hackthebox-lernaen-write-up/</guid>
            <description>HackTheBox is an online platform for testing and advancing skills in penetration testing and cyber security. The site provides vulnerable machines as well as dedicated challenges in areas such as forensics, cryptography and web applications. The following is a write-up after completion of HackTheBox&amp;rsquo;s Lernaen web challenge.
Our instance of the challenge will be contained in a Docker container - after starting the instance you&amp;rsquo;ll be given an address, such as docker.</description>
            <content type="html"><![CDATA[<p>HackTheBox is an online platform for testing and advancing skills in penetration testing and cyber security. The site provides vulnerable machines as well as dedicated challenges in areas such as forensics, cryptography and web applications. The following is a write-up after completion of HackTheBox&rsquo;s Lernaen web challenge.</p>

<p>Our instance of the challenge will be contained in a Docker container - after starting the instance you&rsquo;ll be given an address, such as docker.hackthebox.eu, and a port number. Combine the two (in <code>address:port</code> format), and navigate to the full address in a web browser, where we&rsquo;ll see the following:</p>

<p><img src="../assets/htb-lernaen-01.png" alt="Screenshot of the login page for the HackTheBox Lernaen challenge" /></p>

<p>Looking at the source code, there&rsquo;s nothing obviously untoward that we can use to enable us to bypass the login functionality. Attempting some SQL injection, or guessing with common passwords simply dump us back on the same page with an &lsquo;Invalid password!&rsquo; message. So, we&rsquo;ll take the hint and brute force our way in.</p>

<p>If we search the internet for &lsquo;Lernaean&rsquo; then the results reveal that the Lernaen Hydra is a monster in Greek and Roman mythology. This is another huge hint - <a href="https://tools.kali.org/password-attacks/hydra">THC Hydra</a> is a tool used to perform rapid dictionary attacks against a number of protocols, HTTP being one of them. Revisiting the source code again, we can see that the password is being sent to the server by way of a <code>POST</code> form. With this information, and the previously-returned &lsquo;Invalid password!&rsquo; message, combined with a reliable word list, we can use Hydra to brute force our way in.</p>

<p><code>hydra -l admin -P /usr/share/wordlists/rockyou.txt.gz docker.hackthebox.eu http-post-form &quot;/:password=^PASS^:Invalid password!&quot; -s 99999</code></p>

<p>Breaking down the above command, let&rsquo;s take a look at what we&rsquo;re actually doing:</p>

<ul>
<li><code>-l admin</code> - this is the username that we&rsquo;re attempting to login with. As it isn&rsquo;t being provided, we&rsquo;re taking a guess that it&rsquo;ll be a default, such as admin.</li>
<li><code>-P /usr/share/wordlists/rockyou.txt.gz</code> - this is the name/location of the password file, or word list, that we&rsquo;re going to be using. I&rsquo;m running Kali Linux, which provides the reliable RockYou wordlist out of the box.</li>
<li><code>docker.hackthebox.eu</code> - this is the address of the server that we&rsquo;re going to be running our attack against.</li>
<li><code>http-post-form</code> - this is the type of request that we&rsquo;re going to be making, which we discovered in our earlier viewing of the source code.</li>
<li><code>&quot;/:password=^PASS^:Invalid password!&quot;</code> - let&rsquo;s take a look at each instance of this in turn; <code>/</code> specifies the directory where the login page exists, which is the root directory for us; <code>:password=^PASS^</code> is where we assign the element on the page to the <code>PASS</code> variable; <code>:Invalid password!</code> is the message returned when our password has failed.</li>
<li><code>-s 99999</code> - finally, this is the port on the server that we&rsquo;re going to be running our attack against.</li>
</ul>

<p>After running the command, Hydra will deliver the password which allowed for successful login - <code>leonardo</code>. Now we&rsquo;ve found the password, let&rsquo;s login and hopefully capture our flag.</p>

<p><img src="../assets/htb-lernaen-02.png" alt="Screenshot of the successful login page for the HackTheBox Lernaen challenge" /></p>

<p>Almost there, but not quite. The message &lsquo;Too slow&rsquo; makes it sound like there&rsquo;s something going on here that we&rsquo;ll need to intercept - perhaps a redirect. We could attempt to intercept this with a tool like BurpSuite, or, remaining in a terminal,  we could quickly spin up a Python interpreter and use the <a href="https://pypi.org/project/requests/">requests</a> module to make our <code>POST</code> request without following the redirect which we believe to be in place.</p>

<pre><code class="language-python">&gt;&gt;&gt; response = requests.post('http://docker.hackthebox.eu:99999', data={'password': 'leonardo'}, allow_redirects=False)
&gt;&gt;&gt; response.content
b'&lt;h1 style=\'color: #fff;\'&gt;HTB{l1k3_4_b0s5_s0n}&lt;/h1&gt;&lt;script type=&quot;text/javascript&quot;&gt;\n                   window.location = &quot;noooooooope.html&quot;\n              &lt;/script&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Login - Lernaean&lt;/title&gt;\n&lt;/head&gt;\n&lt;body style=&quot;background-color: #cd4e7b;&quot;&gt;\n    &lt;center&gt;\n        &lt;br&gt;&lt;br&gt;&lt;br&gt;\n        &lt;h1&gt;&lt;u&gt;Administrator Login&lt;/u&gt;&lt;/h1&gt;\n        &lt;h2&gt;--- CONFIDENTIAL ---&lt;/h2&gt;\n        &lt;h2&gt;Please do not try to guess my password!&lt;/h2&gt;\n        &lt;form method=&quot;POST&quot;&gt;\n            &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;&lt;br&gt;\n            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;\n        &lt;/form&gt;\n    &lt;/center&gt;\n&lt;/body&gt;\n&lt;/html&gt;'
</code></pre>

<p>Look inside the first <code>h1</code> element and you&rsquo;ll find our flag.</p>
]]></content>
        </item>
        
        <item>
            <title>Deploy a Serverless Flask Application with AWS Lambda</title>
            <link>/posts/deploy-a-serverless-flask-application-with-aws-lambda/</link>
            <pubDate>Wed, 17 Oct 2018 22:00:00 +0000</pubDate>
            
            <guid>/posts/deploy-a-serverless-flask-application-with-aws-lambda/</guid>
            <description>AWS Lambda lets us run code without provisioning or managing servers, paying only for the compute time of the running code. There&amp;rsquo;s no permanent infrastructure, and the server only has a life cycle of 40 milliseconds. AWS provides automatic horizontal scaling for Lambda applications, spinning up and down as many instances as are necessary.
An open source Python library, Zappa gives us the ability to build and deploy serverless, event-driven Python applications on AWS Lambda.</description>
            <content type="html"><![CDATA[

<p><a href="https://aws.amazon.com/lambda/">AWS Lambda</a> lets us run code without provisioning or managing servers, paying only for the compute time of the running code. There&rsquo;s no permanent infrastructure, and the server only has a life cycle of 40 <em>milliseconds</em>. AWS provides automatic horizontal scaling for Lambda applications, spinning up and down as many instances as are necessary.</p>

<p>An open source Python library, <a href="https://github.com/Miserlou/Zappa">Zappa</a> gives us the ability to build and deploy serverless, event-driven Python applications on <a href="https://aws.amazon.com/lambda/">AWS Lambda</a>. Zappa works out of the box with WSGI web applications, such as Flask and Django.</p>

<p>It&rsquo;s quick and easy to deploy a Python WSGI application to AWS Lambda. The below guide assumes you have an AWS account and have created an IAM user with the relevant permissions.</p>

<h3 id="configuration">Configuration</h3>

<p>With <a href="https://pypi.org/project/pip/">pip</a> installed locally, we&rsquo;ll grab the <a href="https://pypi.org/project/awscli/">awscli</a> package.</p>

<pre><code class="language-bash">$ pip install awscli
</code></pre>

<p>Once installed, the <code>aws configure</code> command will be the quickest way to configure our AWS credentials.</p>

<pre><code class="language-bash">$ aws configure
</code></pre>

<p>This command will request four pieces of information.</p>

<pre><code class="language-bash">AWS Access Key ID [None]:
</code></pre>

<p>This is the AWS Access Key ID of our IAM user with the relevant permissions.</p>

<pre><code class="language-bash">AWS Secret Access Key [None]:
</code></pre>

<p>This is the AWS Secret Access Key of our IAM user with the relevant permissions.</p>

<pre><code class="language-bash">Default region name [None]:
</code></pre>

<p>This can be left blank, which will default this value to <code>us-east-1</code>.</p>

<pre><code class="language-bash">Default output format [None]:
</code></pre>

<p>This can also be left blank, which will default this value to <code>json</code>.</p>

<p>After running the command, the credentials will be stored in the AWS credentials file, located at <code>~/.aws/credentials</code>.</p>

<h3 id="deployment">Deployment</h3>

<p>First, we&rsquo;ll create a <code>requirements.txt</code> file which will document the <a href="https://pypi.org/project/pip/">pip</a> libraries our application will be dependent upon. Run the command below.</p>

<pre><code class="language-bash">$ touch requirements.txt
</code></pre>

<p>And then add the following to this file:</p>

<pre><code class="language-bash">awscli
flask
zappa
</code></pre>

<p><a href="https://github.com/Miserlou/Zappa">Zappa</a> needs a virtual environment to run, which we can create like so (after running <code>pip install virtualenv</code>):</p>

<pre><code class="language-bash">$ virtualenv venv
</code></pre>

<p>That command will create our virtual environment in a new directory named <code>venv</code>. We can activate our virtual environment with the following command:</p>

<pre><code class="language-bash">$ source venv/bin/activate
</code></pre>

<p>If we need to deactivate our virtual environment, we can do so by running the command <code>deactivate</code> or by exiting the terminal.</p>

<p>Once in the virtual environment, let&rsquo;s install the <a href="https://pypi.org/project/pip/">pip</a> libraries from our <code>requirements.txt</code> file.</p>

<pre><code class="language-bash">$ pip install -r requirements.txt
</code></pre>

<p>Our Flask application will sit in a file named <code>app.py</code>, which will serve one route that will return a JSON key/value pair.</p>

<pre><code class="language-python">from flask import Flask, jsonify


app = Flask(__name__)

@app.route(&quot;/&quot;)
def index():
	return jsonify({&quot;response&quot;: &quot;Hello world&quot;})

if __name__ == &quot;__main__&quot;:
	app.run()
</code></pre>

<p>In order to deploy our application to AWS, we&rsquo;ll need to run a couple of Zappa commands. The following command begins an interactive process.</p>

<pre><code class="language-bash">$ zappa init
</code></pre>

<p>This will prompt us for a few different values, which we&rsquo;ll leave as their defaults.</p>

<p>The next command we&rsquo;ll run will tell Zappa to bundle and upload our application and it&rsquo;s dependencies. As part of this process, Zappa will create the necessary API gateways.</p>

<pre><code class="language-bash">$ zappa deploy dev
</code></pre>

<p>After running the above command, Zappa will return the URL where the application has been hosted. Hit this URL and we&rsquo;ll get back the following response:</p>

<pre><code class="language-json">{&quot;response&quot;:&quot;Hello world&quot;}
</code></pre>

<p>To remove the AWS Lambda function, and associated API gateway and Cloudwatch logs, we can run the <code>undeploy</code> command.</p>

<pre><code class="language-bash">$ zappa undeploy dev
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Designing Resilient APIs with Idempotency</title>
            <link>/posts/designing-resilient-apis-with-idempotency/</link>
            <pubDate>Sun, 02 Sep 2018 18:50:00 +0000</pubDate>
            
            <guid>/posts/designing-resilient-apis-with-idempotency/</guid>
            <description>How can we design APIs to be resilient when our networks necessarily aren&amp;rsquo;t? An API should be robust enough to handle failure scenarios including connectivity drops, timeouts between resultant calls, and more. If a client makes a request to our API and loses connection during the request, how can we ensure that a successive identical request doesn&amp;rsquo;t alter the state of the system in a way that we weren&amp;rsquo;t expecting?</description>
            <content type="html"><![CDATA[

<p>How can we design APIs to be resilient when our networks necessarily aren&rsquo;t? An API should be robust enough to handle failure scenarios including connectivity drops, timeouts between resultant calls, and more. If a client makes a request to our API and loses connection during the request, how can we ensure that a successive identical request doesn&rsquo;t alter the state of the system in a way that we weren&rsquo;t expecting? This is where <a href="https://en.wikipedia.org/wiki/Idempotence">idempotence</a> comes into play. An idempotent request is one which can be made any number of times with the guarantee that any resulting logic, or side effects, only happen once.</p>

<p>HTTP has two methods as idempotent by default, the <code>PUT</code> and <code>DELETE</code> verbs. A <code>PUT</code> request is utilised to replace an entire entity with the payload included in the request. Therefore, we can safely make a <code>PUT</code> request multiple times, safe in the knowledge that we&rsquo;ll simply overwrite an entity with the <em>same</em> contents. <code>DELETE</code> requests are similar in that if a first <code>DELETE</code> request failed, then a subsequent request would leave the system in the same intended state. Multiple successful <code>DELETE</code> requests might return different status codes in the response (<code>200</code> for the first request, <code>410</code> or <code>404</code> for the second), but again, the state of the system would remain the same. We should be careful not to interpret idempotency as <em>&ldquo;I should receive the same response from multiple identical requests&rdquo;</em> but as <em>&ldquo;The state of the system should be the same when multiple identical requests are made&rdquo;</em>.</p>

<h2 id="how-can-we-implement-idempotency-in-our-apis">How can we implement idempotency in our APIs?</h2>

<p>We&rsquo;ve identified the need to ensure that our API is capable of serving multiple identical requests under conditions of volatility, but how do we implement that in practice? One such way of dealing with such cases is through the use of <strong>idempotency keys</strong>.</p>

<p>An idempotency key is a unique token generated by the client and passed into the header of a request. When a server receives a request containing an idempotency key it stores it for potential later use. Once the server finishes handling the request, it will update the details stored against the idempotency key to mark this request as completed. If possible, the server could also store the result. If a client makes a further request containing the same idempotency key (perhaps they lost connection before the results were retrieved), the server identifies the key it stored previously and serves up the cached results, or, in scenarios where the server does not store a result, it could return a <code>409</code> status code response, detailing that a resource already exists against the idempotency key passed in the request header.</p>

<p>Let&rsquo;s take a look at these examples in more detail. Firstly, our client makes a request to create a new resource by calling our <code>POST</code> HTTP endpoint, passing an idempotency key in the header and a payload in the request body:</p>

<pre><code>POST https://an-api/v1/resources HTTP/1.1
Idempotency-Key: 845c52a3-6b91-4358-9004-e2f94eec48fa
{
    &quot;first_name&quot;: &quot;Jean Luc&quot;,
    &quot;surname&quot;: &quot;Picard&quot;,
    &quot;rank&quot;: &quot;Captain&quot;
}
</code></pre>

<p>Server side, we create a new resource with the attributes specified in the request body and store the idempotency key and the status of the request, which is &lsquo;<code>complete</code>&rsquo;. However, the connection between the client and the server dropped, so we&rsquo;ve been unable to return a response to the client. In this case, the client retries their request, re-sending an identical idempotency key and payload. The server cross references the incoming idempotency key with those contained in storage, identifies that it is a duplicate key and returns the following response:</p>

<pre><code>HTTP/1.1 409 (Conflict)
{
    &quot;error&quot;: &quot;A resource has previously been created using this idempotency key&quot;
}
</code></pre>

<p>Let&rsquo;s re-use the above example, but consider this time that the server has stored the response it would have sent had the connection between client and server not dropped. Again, the client retries their request, re-sending the identical idempotency key and payload. The server again cross references the incoming idempotency key with those contained in storage, identifies that it is a duplicate key and returns the cached response:</p>

<pre><code>HTTP/1.1 201 (CREATED)
{
    &quot;message&quot;: &quot;Resource created successfully&quot;
}
</code></pre>

<p>In our final scenario, perhaps the server was unable to complete the request due to a failure part-way through processing. The logic and resultant behaviour here depends on how the idempotency is implemented on the server. In this situation, the server might have stored the state of the request against the idempotency key at certain points of operation, in which case upon a re-request from the client, the server can cross reference the incoming idempotency key in a re-request with those in storage and identify at which point the transaction was aborter. The server can then continue processing before sending back a response. Another implementation might be that the entire operation was rolled back via an ACID database, meaning that the server can re-process the request from scratch.</p>

<p>The server side storage of idempotency keys should be recycled periodically. We wouldn&rsquo;t expect a dropped connection re-request to happen 24 hours after the original request, so this isn&rsquo;t the kind of data which we need to store long term.</p>

<p>In a future blog post I&rsquo;ll look at a lightweight implementation of idempotency in both Flask and Django web applications.</p>
]]></content>
        </item>
        
        <item>
            <title>Python 3.7 Data Classes</title>
            <link>/posts/python-3.7-data-classes/</link>
            <pubDate>Sun, 08 Jul 2018 19:50:00 +0000</pubDate>
            
            <guid>/posts/python-3.7-data-classes/</guid>
            <description>PEP 557 in the recently-released [Python 3.7]() added data classes to the standard Python library. Data classes can be thought of as mutable data holders and are somewhat similar to named tuples, although named tuples are immutable.
Data classes provide a lot of boilerplate code, saving time and effort on the part of the Python programmer, although it could be argued that this layer of abstraction makes debugging more difficult.</description>
            <content type="html"><![CDATA[

<p><a href="https://www.python.org/dev/peps/pep-0557/">PEP 557</a> in the recently-released [Python 3.7]() added data classes to the standard Python library. Data classes can be thought of as mutable data holders and are somewhat similar to <a href="https://docs.python.org/2/library/collections.html#collections.namedtuple">named tuples</a>, although named tuples are immutable.</p>

<p>Data classes provide a lot of boilerplate code, saving time and effort on the part of the Python programmer, although it could be argued that this layer of abstraction makes debugging more difficult.</p>

<h2 id="comparing-regular-classes-and-data-classes">Comparing regular classes and data classes</h2>

<p>Consider the following class:</p>

<pre><code class="language-python">class BankAccount():
	def __init__(self, id, balance, customer_id):
		self.id = id
		self.balance = balance
		self.customer_id = customer_id
</code></pre>

<p>This provides us with the minimal ability to initialise a new BankAccount object, although we&rsquo;ve had to reference <code>id</code>, <code>balance</code>, and <code>customer_id</code> three times in this small piece of code.</p>

<p>Let&rsquo;s initialise two new objects using our <code>BankAccount</code> class - <code>my_account</code> and <code>your_account</code>. We&rsquo;ll initialise both with the same values, ignoring the fact that they should have different <code>id</code> and <code>customer_id</code> values, then try and compare them to each other.</p>

<pre><code class="language-python">&gt;&gt;&gt; my_account = BankAccount(1, 0, 1)
&gt;&gt;&gt; your_account = BankAccount(1, 0, 1)
&gt;&gt;&gt; my_account == your_account
False
</code></pre>

<p>In order to be able to compare our <code>my_account</code> and <code>your_account</code> objects successfully, we&rsquo;d need to add an <code>__eq__</code> method to our class.</p>

<pre><code class="language-python">class BankAccount():
	def __init__(self, id, balance, customer_id):
		self.id = id
		self.balance = balance
		self.customer_id = customer_id

	def __eq__(self, other):
		if self.__class__ is other.__class__:
			return (self.id, self.balance, self.customer_id) == (other.id, other.balance, other.customer_id)
		return NotImplemented
</code></pre>

<p>If we initialise our two objects again and compare them now, we&rsquo;ll get the <code>True</code> response that we&rsquo;re expecting. If we were to initialise the <code>your_account</code> object with an <code>id</code> value of <code>2</code>, and a <code>customer_id</code> value of <code>2</code>, we&rsquo;d get the correct response of <code>False</code> when comparing the two objects.</p>

<pre><code class="language-python">&gt;&gt;&gt; my_account = BankAccount(1, 0, 1)
&gt;&gt;&gt; your_account = BankAccount(1, 0, 1)
&gt;&gt;&gt; my_account == your_account
True
&gt;&gt;&gt; your_account = BankAccount(2, 0, 2)
&gt;&gt;&gt; my_account == your_account
False
</code></pre>

<p>This all makes sense so far, but it&rsquo;s boilerplate code that we have to write each and every time that we write a new class. Let&rsquo;s take a look at how we&rsquo;d do the same thing with 3.7&rsquo;s data classes.</p>

<pre><code class="language-python">from dataclasses import dataclass

@dataclass
class DataClassBankAccount():
	id: int
	balance: int
	customer_id: int
</code></pre>

<p>Data classes generate all of this boilerplate code for us, but they don&rsquo;t stop at just the <code>__init__</code> and <code>__eq__</code> methods - they can also generate <code>__repr__</code>, <code>__ne__</code>, <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, and <code>__ge__</code> methods too, if the <code>order</code> parameter is specified as <code>True</code> (this is done at the <code>@dataclass</code> level, i.e. <code>@dataclass(order=True)</code>). Additional methods can be added to the data class as you would for a normal class. The <code>@dataclass</code> decorator inspects a class definition for fields with type annotations (added in <a href="https://www.python.org/dev/peps/pep-0526/">PEP 526</a>). These type annotations are <em>mandatory</em> when creating data classes as fields without type annotations will simply be ignored. We can now initialise and compare our two objects straight away:</p>

<pre><code class="language-python">&gt;&gt;&gt; my_account = DataClassBankAccount(1, 0, 1)
&gt;&gt;&gt; your_account = DataClassBankAccount(1, 0, 1)
&gt;&gt;&gt; my_account == your_account
True
&gt;&gt;&gt; your_account = DataClassBankAccount(2, 0, 2)
&gt;&gt;&gt; my_account == your_account
False
</code></pre>

<p>As mentioned in <a href="https://www.python.org/dev/peps/pep-0557/">PEP 557</a>, there isn&rsquo;t anything special about these classes. The decorator takes the class and adds generated methods to it, then returns the class it was given. This means adding your own methods to a data class is done in exactly the same way as you would for a regular class.</p>

<h2 id="comparing-named-tuples-and-data-classes">Comparing named tuples and data classes</h2>

<p>Let&rsquo;s compare for a moment our bank account data class and an implementation of the bank account using a named tuple.</p>

<pre><code class="language-python">from typing import NamedTuple

class NamedTupleBankAccount(NamedTuple):
	id: int
	balance: int
	customer_id: int
</code></pre>

<p>There&rsquo;s no great difference here, other than the fact that our data class was described using a decorator, whilst the named tuple subclasses <code>NamedTuple</code>. There are other similarities too. For instance, with our data class we can create a new object from an existing data class object.</p>

<pre><code class="language-python">&gt;&gt;&gt; from dataclasses import replace
&gt;&gt;&gt;
&gt;&gt;&gt; replace(my_account, balance=100)
BankAccount(id=1, balance=100, customer_id=1)
</code></pre>

<p>We&rsquo;d do this in a similar way with a named tuple, but the replace method here is proceded by an underscore, indicating that it is a private method of our named tuple bank account object.</p>

<pre><code class="language-python">&gt;&gt;&gt; our_account = NamedTupleBankAccount(3, 0, 3)
&gt;&gt;&gt;
&gt;&gt;&gt; our_account._replace(balance=100)
NamedTupleBankAccount(id=3, balance=100, customer_id=3)
</code></pre>

<p>Data classes also provide methods for conversion to dictionaries and tuples.</p>

<pre><code class="language-python">&gt;&gt;&gt; from dataclasses import asdict, astuple
&gt;&gt;&gt;
&gt;&gt;&gt; asdict(my_account)
{'id': 1, 'balance': 0, 'customer_id': 1}
&gt;&gt;&gt;
&gt;&gt;&gt; astuple(my_account)
(1, 0, 1)
</code></pre>

<p>And similarly, the <code>asdict</code> method exists as a private method of our named tuple object, with the key difference being that this returns an <code>OrderedDict</code> rather than a standard dict.</p>

<pre><code class="language-python">&gt;&gt;&gt; our_account._asdict()
OrderedDict([('id', 3), ('balance', 0), ('customer_id', 3)])
</code></pre>

<p>You can unpack a named tuple rather simply, but must first wrap a data class object in a call to <code>astuple</code> before it is possible to unpack - this is because data classes don&rsquo;t iterate by default.</p>

<pre><code class="language-python">&gt;&gt;&gt; our_account_id, our_balance, our_customer_id = our_account
&gt;&gt;&gt; our_account_id
3
&gt;&gt;&gt;
&gt;&gt;&gt; my_account_id, my_balance, my_customer_id = astuple(my_account)
&gt;&gt;&gt; my_account_id
1
</code></pre>

<p>Data classes can&rsquo;t be hashed by default, whereas named tuples can - data classes actually set <code>__hash__</code> to <code>None</code> in order to avoid accidental hashability. Named tuples provide hashability and ordering out of the box, as they are inherited from tuples.</p>

<p>Equality methods between the two types are different as well. It&rsquo;s possible to compare two different named tuple objects instantiated from two different named tuple classes which happen to have the same field naming - this is because named tuples lack the <code>if self.__class__ is other.__class__:</code> conditional that data classes provide in their equality methods.</p>

<p>As of Python 3.7 it is slower to access fields of a named tuple than those of a data class, though <a href="https://twitter.com/raymondh">Raymond Hettinger</a> mentions in his PyCon 2018 talk &lsquo;<a href="https://www.youtube.com/watch?v=T-TwcmT6Rcw">Dataclasses: The code generator to end all code generators</a>&rsquo; that this timing will be improved significantly in Python 3.8. You can find the slides for Raymond&rsquo;s PyCon talk <a href="https://twitter.com/raymondh/status/995693882812915712">here</a>.</p>

<p>You shouldn&rsquo;t think of data classes as an improvement upon a named tuple - if that&rsquo;s what fits the structure of your data, then that&rsquo;s what you should use.</p>

<h2 id="additional-data-class-usages">Additional data class usages</h2>

<h3 id="default-values">Default values</h3>

<p>We can set default values for our specified data class fields. Let&rsquo;s take a look at how we&rsquo;d do that with a normal class.</p>

<pre><code class="language-python">class Animal:
	def __init__(self, type, legs=4):
		self.type = type
		self.legs = legs
</code></pre>

<p>When declaring our data class, we declare our default value(s) differently.</p>

<pre><code class="language-python">@dataclass
class Animal:
	type: str
	legs: int = 4
</code></pre>

<p>The above data class will give the below output when initialising objects.</p>

<pre><code class="language-python">&gt;&gt;&gt; Animal(&quot;dog&quot;)
Animal(type=&quot;dog&quot;, legs=4)
&gt;&gt;&gt; Animal(&quot;ostrich&quot;, 2)
Animal(type=&quot;ostrich&quot;, legs=2)
</code></pre>

<p>Building upon our original BankAccount class we can take a look at a more advanced default value. Let&rsquo;s say for each bank account object, we want to track who accessed the bank account and when. We&rsquo;ll create a more advanced BankAccount class that features this functionality.</p>

<pre><code class="language-python">from dataclass import field
from datetime import datetime

@dataclass
class AdvancedBankAccount():
	id: int
	balance: int = field(metadata={&quot;currency&quot;: &quot;GBP&quot;})
	customer_id: int
	accessed_by: list = field(default_factory=list)

	def access(self, accessor_id):
		self.accessed_by.append((accessor_id, datetime.now()))
</code></pre>

<pre><code class="language-python">&gt;&gt;&gt; advanced_account = AdvancedBankAccount(4, 10000, 4)
&gt;&gt;&gt; advanced_account.access(1)
&gt;&gt;&gt; advanced_account
AdvancedBankAccount(id=4, balance=10000, customer_id=4, accessed_by=[(1, datetime.datetime(2018, 7, 8, 19, 30, 40, 783467))])
</code></pre>

<p>The <code>default_factory</code> is used to provide a mutable default value. Additionally, we&rsquo;ve also passed a metadata parameter which specifies some metadata about the field, in this case the currency of the <code>balance</code>. The dataclass itself won&rsquo;t do anything with this, but you can view it using the <code>fields</code> function.</p>

<h3 id="field-arguments">Field arguments</h3>

<p>We can pass some additional arguments when creating our data classes.</p>

<p>We can not include a specific field in the output of the class <code>__repr__</code> method.</p>

<pre><code class="language-python">from dataclasses import field

@dataclass
class Animal():
	type: str = field(repr=False)
	legs: int = 4
</code></pre>

<p>And we could also not include a specific field when comparing two objects from the same data class.</p>

<pre><code class="language-python">from dataclasses import field

@dataclass
class Animal():
	type: str = field(order=False)
	legs: int = 4
</code></pre>

<h3 id="immutable-data-classes">Immutable data classes</h3>

<p>Data classes are mutable by default, but there might be scenarios where we want to maintain the immutability that a named tuple offers us.</p>

<pre><code class="language-python">from dataclasses import field

@dataclass(frozen=True)
class Animal():
	type: str
	legs: int
</code></pre>

<p>The <code>frozen=True</code> argument that we&rsquo;ve passed to the <code>@dataclass</code> decorator means that we won&rsquo;t be able to assign values to any objects created from this data class after their initialisation.</p>

<pre><code class="language-python">&gt;&gt;&gt; cat = Animal(&quot;cat&quot;, 4)
&gt;&gt;&gt; cat.legs = 3
dataclasses.FrozenInstanceError: cannot assign to field 'legs'
</code></pre>

<h2 id="further-reading">Further reading</h2>

<ul>
<li><a href="https://www.python.org/dev/peps/pep-0557/">PEP557</a></li>
<li><a href="https://www.youtube.com/watch?v=T-TwcmT6Rcw">Dataclasses: The code generator to end all code generators</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>GitLab Changelog Generator</title>
            <link>/posts/gitlab-changelog-generator/</link>
            <pubDate>Sat, 23 Jun 2018 22:50:00 +0000</pubDate>
            
            <guid>/posts/gitlab-changelog-generator/</guid>
            <description>I&amp;rsquo;ve recently written a small command line utility using Python 3.6 which will produce a CHANGELOG.md file from the commit differences between two different GitLab project branches. I&amp;rsquo;ve released this as an open source Python package and it&amp;rsquo;s available from PyPi here. Not intended to be a direct replacement for writing a manual changelog, the utility should be used as a draft upon which to build.
This was a small project to trial a few things; Python&amp;rsquo;s type hinting, which was added in PEP484; Facebook Open Source&amp;rsquo;s type checker Pyre; and Black &amp;lsquo;the uncompromising Python code formatter&amp;rsquo;.</description>
            <content type="html"><![CDATA[<p>I&rsquo;ve recently written a small command line utility using Python 3.6 which will produce a <code>CHANGELOG.md</code> file from the commit differences between two different GitLab project branches. I&rsquo;ve released this as an open source Python package and it&rsquo;s available from PyPi <a href="https://pypi.org/project/pip/">here</a>. Not intended to be a direct replacement for writing a manual changelog, the utility should be used as a draft upon which to build.</p>

<p>This was a small project to trial a few things; Python&rsquo;s type hinting, which was added in <a href="https://www.python.org/dev/peps/pep-0484/">PEP484</a>; <a href="https://opensource.fb.com/">Facebook Open Source&rsquo;s</a> type checker <a href="https://pyre-check.org/">Pyre</a>; and <a href="https://github.com/ambv/black">Black</a> &lsquo;the uncompromising Python code formatter&rsquo;.</p>

<p>If you&rsquo;re interested in using this utility, you can install it using <a href="https://pypi.org/project/pip/">pip</a> by running the following command:</p>

<pre><code class="language-bash">$ pip install gitlab-changelog-generator
</code></pre>

<p>An example command to generate a <code>CHANGELOG.md</code> file from the difference in commits between <code>master</code> and <code>release</code> branches for a locally hosted GitLab repository project named &lsquo;test-project&rsquo;, labelling the version as 1.1.</p>

<pre><code class="language-bash">$ changegen --ip localhost --group test-projects --project test-project --branches master release --version 1.1
</code></pre>

<p>I&rsquo;ve got some tidying up left to do such as better exception handling and cleaner logging, but the package works in it&rsquo;s current state. You can contribute features or towards existing issues by raising a <a href="https://help.github.com/articles/creating-a-pull-request/">pull request</a> at the project GitHub <a href="https://github.com/stuartmccoll/gitlab-changelog-generator">repository</a>.</p>
]]></content>
        </item>
        
        <item>
            <title>Add a Flask Application to a Docker Container</title>
            <link>/posts/add-a-flask-application-to-a-docker-container/</link>
            <pubDate>Sun, 14 May 2017 10:10:32 +0000</pubDate>
            
            <guid>/posts/add-a-flask-application-to-a-docker-container/</guid>
            <description>Flask is a microframework for Python, based on Werkzeug and Jinja2. The core Flask framework is extremely lightweight, albeit infinitely extensible, and it&amp;rsquo;s simple for an experienced developer to pick up. I had been using Laravel a lot at the beginning of the year and Flask has been a breeze to work with in comparison. With it&amp;rsquo;s extensibility I haven&amp;rsquo;t been locked into working with pre-defined components either; I&amp;rsquo;ve used different database abstraction layers across multiple projects, such as Redis and PostgreSQL.</description>
            <content type="html"><![CDATA[

<p><a href="http://flask.pocoo.org/">Flask</a> is a microframework for Python, based on <a href="http://werkzeug.pocoo.org/">Werkzeug</a> and <a href="http://jinja.pocoo.org/docs/2.9/">Jinja2</a>. The core Flask framework is extremely lightweight, albeit infinitely extensible, and it&rsquo;s simple for an experienced developer to pick up. I had been using Laravel a lot at the beginning of the year and Flask has been a breeze to work with in comparison. With it&rsquo;s extensibility I haven&rsquo;t been locked into working with pre-defined components either; I&rsquo;ve used different database abstraction layers across multiple projects, such as <a href="https://redis.io/">Redis</a> and <a href="https://www.postgresql.org/">PostgreSQL</a>.</p>

<p>We&rsquo;ll need a few things to begin, the first of which is a directory to house our Flask application, which we&rsquo;ll call <strong>flask_docker</strong>.</p>

<pre><code class="language-bash">$ mkdir flask_docker
</code></pre>

<p>Within this directory we&rsquo;re going to need to create two different files. Firstly, we&rsquo;ll create our Flask application. For this, I&rsquo;m going to create a simple Flask app that&rsquo;ll return a string of text when the root directory is hit within a web browser.</p>

<pre><code class="language-python">from flask import Flask
app = Flask(__name__)

@app.route('/')
def simple():
    return 'Flask running within Docker container'

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0')
</code></pre>

<p>With our basic Flask app written, we now want to be able to build our Docker image. We have a few options here, in that we could build from a base image of Ubuntu or something similar, but in this instance I&rsquo;m just going to use the base Python 2.7 Docker image.</p>

<pre><code class="language-docker">FROM python:2.7

RUN pip install flask

ADD . /app

WORKDIR /app

EXPOSE 5000

CMD [&quot;python&quot;, &quot;app.py&quot;]
</code></pre>

<p>Once our base image has been established, our Dockerfile has a few more commands within it. Firstly, we&rsquo;re installing the Flask pip package (pip is included within the Python 2.7 Docker image that we our basing our own Docker image upon). After this, we copy the contents of the current directory to the &lsquo;/app&rsquo; directory within our Docker container, and then we set that as the current working directory. Following this, we expose port 5000 before lastly running the command that&rsquo;ll run our Flask application.</p>

<h2 id="building-the-docker-image">Building the Docker Image</h2>

<pre><code class="language-bash">$ docker build -t our-flask-app .
</code></pre>

<p>This command will build the Dockerfile within the current working directory, giving the image a name of &lsquo;our-flask-app&rsquo;.</p>

<pre><code class="language-bash">$ docker run -d -p 5000:5000 our-flask-app
</code></pre>

<p>Lastly, this command builds our Docker container, which in turn runs our Flask application. The arguments we pass in here run the container in headless mode and map port 5000 on our local machine to port 5000 within our Docker container. Now, if we visit <a href="http://0.0.0.0:5000/">http://0.0.0.0:5000/</a> in a web browser we&rsquo;ll be served the string that our Flask application returns.</p>
]]></content>
        </item>
        
        <item>
            <title>Quick and Dirty Kombu/RabbitMQ Application</title>
            <link>/posts/quick-and-dirty-kombu/rabbitmq-application/</link>
            <pubDate>Sun, 14 May 2017 10:10:32 +0000</pubDate>
            
            <guid>/posts/quick-and-dirty-kombu/rabbitmq-application/</guid>
            <description>Kombu is an open-source messaging library available for Python which aims to make messaging as simple as possible. Kombu provides a high-level interface for the Advanced Message Queuing Protocol (AMQP), an open standard protocol for message orientation, queuing, routing, reliability, and security. The most popular implementation of AMQP is the RabbitMQ open-source messaging server.
In the example application we&amp;rsquo;re going to create here, we&amp;rsquo;re going to use Kombu and RabbitMQ in combination to do the following:</description>
            <content type="html"><![CDATA[

<p><a href="https://github.com/celery/kombu">Kombu</a> is an open-source messaging library available for Python which aims to make messaging as simple as possible. Kombu provides a high-level interface for the <a href="http://amqp.org/">Advanced Message Queuing Protocol</a> (AMQP), an open standard protocol for message orientation, queuing, routing, reliability, and security. The most popular implementation of AMQP is the <a href="http://www.rabbitmq.com/">RabbitMQ</a> open-source messaging server.</p>

<p>In the example application we&rsquo;re going to create here, we&rsquo;re going to use Kombu and RabbitMQ in combination to do the following:</p>

<ul>
<li>Send a message from a Kombu application (in this case a simple Python script).</li>
<li>Receive the message at an exchange (our RabbitMQ server), which will then place the message on a queue.</li>
<li>Read from the queue within another Kombu application (in this case, another simple Python script).</li>
</ul>

<p>The application we&rsquo;re going to create will only feature one queue, one script which will fire a message at the exchange (our producer), and another script that will read from the queue as soon as it finds something on it (our consumer). It&rsquo;s a basic example, but we could build upon and utilise this for any number of uses.</p>

<h2 id="tutorial">Tutorial</h2>

<p>Let&rsquo;s begin with our script that&rsquo;ll consume messages - <code>consumer.py</code>.</p>

<p>In order to send and receive messages, we&rsquo;ll need to fulfil a few prerequisites. Firstly, we need to create a connection to our RabbitMQ server.</p>

<pre><code class="language-python">conn = Connection(&quot;amqp://localhost:5672/&quot;)
</code></pre>

<p>We&rsquo;ll use this connection in a moment when we instantiate the Consumer class. Next, we&rsquo;ll create our exchange.</p>

<pre><code class="language-python">test_exchange = Exchange(&quot;test_exchange&quot;, type=&quot;direct&quot;)
</code></pre>

<p>The first parameter passed gives the name of our exchange and the second parameter dictates what type of exchange we&rsquo;re creating. Here, we can pass either direct (matches  if the routing_key attribute and the routing key property of the message are identical), fanout (always matches), and topic (matches the routing key property of the message by a pattern matching scheme). For this small example we&rsquo;re going to create a simple direct exchange.</p>

<p>With a connection and an exchange created, we&rsquo;re now going to create our queue. This is what we&rsquo;ll drop our messages onto before consuming them.</p>

<pre><code class="language-python">queue = Queue(name=&quot;queue&quot;, exchange=test_exchange, routing_key=&quot;test&quot;)
</code></pre>

<p>To configure our queue, we&rsquo;re simply giving it a name, passing an exchange to it, and a routing key. The routing key will be utilised based on the type of the exchange, as we&rsquo;ve set above.</p>

<p>Lastly, we need to set up our Consumer. A Consumer needs a connection (or channel) and a list of queues to consume from. We&rsquo;re also going to pass it a callback, which is a function which it&rsquo;ll call when it finds an event on our queue.</p>

<pre><code class="language-python">with Consumer(conn, queues=queue, callbacks=[process_message], accept=[&quot;text/plain&quot;]):
    conn.drain_events()
</code></pre>

<p>Our Consumer takes our connection variable, our queue, and a callback to a process_message function which we&rsquo;ll create in a moment. We&rsquo;re not passing any kind of timeout only because for this example we want it to consume messages indefinitely to give an idea of how Kombu and RabbitMQ work. I&rsquo;ll expand upon this further in future posts where I&rsquo;ll be looking at putting Kombu to a more functional use.</p>

<p>Here&rsquo;s our <code>consumer.py</code> file in full:</p>

<pre><code class="language-python">from kombu import Connection, Exchange, Consumer, Queue
from process_message import process_message

# Create the connection
conn = Connection(&quot;amqp://localhost:5672/&quot;)

# Create the exchange
test_exchange = Exchange(&quot;test_exchange&quot;, type=&quot;direct&quot;)

# Create the queue
queue = Queue(name=&quot;queue&quot;, exchange=test_exchange, routing_key=&quot;test&quot;)

# Create the consumer
with Consumer(conn, queues=queue, callbacks=[process_message],
              accept=[&quot;text/plain&quot;]):
</code></pre>

<p>Now, to create our <code>process_message</code> function. This is going to live in it&rsquo;s own <code>process_message.py</code> file.</p>

<pre><code class="language-python">def process_message(body, message):
    print &quot;The following message has been received: %s&quot; % body

    # Acknowledge the message
    message.ack()
</code></pre>

<p>This function receives the body and message of our event, prints a statement to the console detailing what has been received, then acknowledges the message. By acknowledging the message we remove it from the queue.</p>

<p>At this stage, we have our queue ready to put messages on, we&rsquo;ve got a consumer that&rsquo;s ready to grab messages off the queue, and we&rsquo;ve also got a function that&rsquo;s going to process the message once we&rsquo;ve taken it from the queue. The only thing left to do is to set up our producer, which is what will drop our messages onto the queue.</p>

<p>A lot of our <code>producer.py</code> file is going to look similar to our <code>consumer.py</code> file.</p>

<pre><code class="language-python">conn = Connection(&quot;amqp://localhost:5672/&quot;)
</code></pre>

<p>We need to set up our connection as before.</p>

<pre><code class="language-python">channel = conn.channel()
</code></pre>

<p>Then we create and return a new channel.</p>

<pre><code class="language-python">test_exchange = Exchange(&quot;test_exchange&quot;, type=&quot;direct&quot;)
</code></pre>

<p>We create our exchange in the same way that we did within our <code>consumer.py</code> file.</p>

<pre><code class="language-python">producer = Producer(exchange=test_exchange, channel=channel, routing_key=&quot;test&quot;)
</code></pre>

<p>Our instantiation of the Producer class looks similar to the way we instantiated our Consumer class. We pass in our exchange and our channel, and then we also pass in the same routing_key that we gave to our consumer. As we&rsquo;re using a direct exchange, we need to make sure that our messages are going to the same place, which is why we ensure that we pass in the same routing_key to both the producer and the consumer.</p>

<pre><code class="language-python">producer.publish(&quot;Hello World!&quot;)
</code></pre>

<p>Lastly, we call the publish method and pass through a string as our message. Whenever we run the <code>producer.py</code> script this will send our message to the exchange.</p>

<p>Here&rsquo;s our <code>producer.py</code> in full:</p>

<pre><code class="language-python">from kombu import Connection, Exchange, Producer

# Create the connection
conn = Connection(&quot;amqp://localhost:5672/&quot;)

# Create a new channel
channel = conn.channel()

# Create the exchange
test_exchange = Exchange(&quot;test_exchange&quot;, type=&quot;direct&quot;)

# Create the producer
producer = Producer(exchange=test_exchange, channel=channel,
                    routing_key=&quot;test&quot;)

# Publish a message
producer.publish(&quot;Hello World!&quot;)
</code></pre>

<p>If we run our <code>consumer.py</code> script now, it&rsquo;ll run indefinitely and wait until it finds something on the queue we&rsquo;ve created. Now, if we run <code>producer.py</code> it&rsquo;ll fire a message at the exchange which will route it onto the queue. The already-running <code>consumer.py</code> will find it on the queue and process it, which removes it from the queue.</p>

<p>A simple example that doesn&rsquo;t do anything of use, but I hope it&rsquo;s given you an insight into the way Kombu and RabbitMQ work together.</p>
]]></content>
        </item>
        
    </channel>
</rss>
